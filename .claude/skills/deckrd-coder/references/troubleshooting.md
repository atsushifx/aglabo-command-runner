---
title: TROUBLESHOOTING - フロー逸脱時の対応ガイド
---

<!-- textlint-disable ja-technical-writing/no-mix-dearu-desumasu -->
<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->
<!-- markdownlint-disable line-length no-duplicate-heading -->

## TROUBLESHOOTING - フロー逸脱時の対応ガイド

本ドキュメントは、`workflow.md` および `implementation.md` で定義されたフローから逸脱する場合の代表例と、それに対する具体的な対応を記述しています。

---

## WORKFLOW フロー逸脱時の対応

### 逸脱 1: Phase 0 (開発環境把握) のスキップ

#### 症状

- 開発言語やツール設定を確認せずにコーディング開始
- コマンド実行エラーが多発する
- 環境依存のバグが後から発覚

#### 原因

- リポジトリルート・サブパッケージルートの特定漏れ
- `package.json`、`Cargo.toml`、`setup.py` などの確認忘れ
- Lint、型チェック、テストコマンドの事前調査不足

#### 対応

1. **即座に Phase 0 へ戻る**
   - リポジトリルートを確認: `pwd` / `ls -la`
   - 開発言語を確認: `cat package.json` | `cat Cargo.toml` など
   - 利用ツール一覧を記録: 開発環境のドキュメント確認

2. **実行コマンドを記録**

   ```bash
   # 例: Node.js プロジェクト
   npm run lint          # Lint チェック
   npm run check:types   # 型チェック
   npm run test          # テスト実行

   # 例: Python プロジェクト
   python -m flake8      # Lint
   mypy .                # 型チェック
   pytest                # テスト
   ```

3. **コマンド実行テスト**
   - 各コマンドが正常に実行されることを確認
   - ヘルプオプション確認: `npm run lint --help` など

4. **Phase 1 に進む**

---

### 逸脱 2: Phase 1 (アクティブタスク取得) の不完全実行

#### 症状

- `.session.json` の `active` フィールドが未設定
- タスク ID が不明確
- テストケース一覧が取得できない

#### 原因

- `docs/.deckrd/.session.json` ファイルが存在しない
- Session JSON のフォーマットエラー
- アクティブセッション情報が古い

#### 対応

1. **Session JSON ファイルの確認**

   ```bash
   # ファイル存在確認
   ls -la docs/.deckrd/.session.json

   # 内容確認
   cat docs/.deckrd/.session.json | jq .
   ```

2. **Session JSON が存在しない場合**

   ```bash
   # Deckrd セッション初期化
   deckrd init

   # アクティブセッションを設定
   deckrd session set --active <TASK_ID>
   ```

3. **Session JSON が存在するが形式が不正な場合**
   - ファイルを削除して再初期化
   - JSON バリデーター使用: `jq . docs/.deckrd/.session.json`

4. **アクティブタスク情報が古い場合**
   - セッション情報を最新化: `deckrd session refresh`
   - または新規セッション作成: `deckrd session create <TASK_ID>`

5. **Phase 2 に進む**

---

### 逸脱 3: Phase 2 (実装タスクリスト作成) の細分化不足

#### 症状

- タスクが粗すぎて「1 message = 1 test」原則が守れない
- 複数テストを同時実装してしまう
- タスク間の依存関係が不明確

#### 原因

- ユーザー要件を十分に分析していない
- テストケースごとの分割が不十分
- 依存関係マッピングの遺漏

#### 対応

1. **タスク細分化を再実施**

   ```markdown
   # 悪い例

   - [ ] Task: ユーザー認証機能を実装

   # 良い例

   - [ ] Task 1: 入力値が有効な場合、ユーザーを認証 (正常系)
   - [ ] Task 2: パスワード不正な場合、エラーを返す (異常系)
   - [ ] Task 3: ユーザーが存在しない場合、デフォルト処理 (エッジケース)
   ```

2. **各タスクの独立性を確認**
   - 各タスクが単一テストケース対応であることを確認
   - タスク A の成否がタスク B に影響しないことを確認

3. **依存関係マッピングを作成**

   ```markdown
   Task 1 (基本認証)
   ↓
   Task 2 (エラーハンドリング)
   ↓
   Task 3 (追加検証)
   ```

4. **Phase 3 に戻る**

---

### 逸脱 4: Phase 3 (コーディング実行) 中の品質ゲート忘却

#### 症状

- テストは通るが、Lint・型チェックでエラー多発
- ユーザーが修正依頼を出す
- ワークフローが巻き戻される

#### 原因

- Step 5 (品質ゲート実行) の重要性を過小評価
- 個別タスク終了時に品質ゲート確認の仕組みがない
- deckrd-bdd-coder のエラー通知を見落とし

#### 対応

1. **各タスク終了時に品質ゲート実行を必須化**
   - deckrd-bdd-coder は品質ゲート合格を処理完了条件とする
   - Lint チェック: `npm run lint` など
   - 型チェック: `npm run check:types` など

2. **品質ゲート失敗時の対応**
   - エラー内容を分析
   - 修正コード作成
   - 再度品質ゲート実行
   - **3 回以上失敗時: ロールバックしてユーザーに相談**

3. **Phase 4 へ進む前に全体品質ゲート確認**
   - すべてのタスクが品質ゲート合格していることを確認

---

### 逸脱 5: Phase 4 (品質ゲート実行) での失敗対応の混乱

#### 症状

- 品質ゲートが失敗したまま放置
- 対応方法が不明確
- Step 5 と Step 7 の処理が区別できていない

#### 原因

- Phase 4 と Step 5 の役割区分が不明確
- 個別エラーの対応方法が体系化されていない
- エラー 3 回以上時のユーザー相談の判断基準が曖昧

#### 対応

1. **Phase 4 (全体品質ゲート) での失敗時フロー**

   ```bash
   品質ゲート実行
     ↓
   Lint 失敗
     → コードの様式違反を修正
     → Lint 再実行
     → 失敗カウント +1

   型チェック失敗
     → 型定義を確認
     → インポート・型注釈を修正
     → 型チェック再実行
     → 失敗カウント +1

   テスト失敗
     → テストの失敗原因を分析
     → 実装コード・テストコードを修正
     → テスト再実行
     → 失敗カウント +1

   失敗カウント ≥ 3
     → Step 7 (Refactor) へ戻って全体見直し
     → または ユーザーに相談
   ```

2. **エラー別の具体的対応**

   | エラー種別     | 原因例                         | 対応                                   |
   | -------------- | ------------------------------ | -------------------------------------- |
   | Lint 失敗      | セミコロン漏れ、インデント不正 | `.eslintrc.json` 確認後、該当行修正    |
   | 型チェック失敗 | 型注釈不正、any の多用         | `tsconfig.json` 確認後、型定義を厳格化 |
   | テスト失敗     | ロジックバグ、テスト条件不正   | デバッグログ追加後、ロジック修正       |

3. **Phase 5 へ進む条件**
   - Lint チェック: **合格**
   - 型チェック: **合格**
   - テスト: **すべてグリーン**

---

### 逸脱 6: Phase 5 (完了確認) のスキップ

#### 症状

- 実装が完了していないまま次ステップに進む
- 後から漏れたテストケースが発見される
- ユーザーが再度修正依頼を出す

#### 原因

- 実装タスクリストの確認不足
- すべてのテストが通ったことの検証漏れ
- Refactor フェーズの実施確認不足

#### 対応

1. **実装タスクリストを確認**

   ```markdown
   - [x] Task 1: ... (実装済み、テスト合格)
   - [x] Task 2: ... (実装済み、テスト合格)
   - [x] Task 3: ... (実装済み、テスト合格)

   ✓ すべてチェック済みを確認
   ```

2. **全テスト実行**

   ```bash
   npm run test

   # 結果確認
   # 合格テスト数 = 予期する総テスト数？
   ```

3. **Refactor 完了確認**
   - Step 7 で全体コード整理が完了しているか確認
   - ユーザーが Refactor 内容に承認しているか確認

4. **Phase 6 へ進む**

---

## IMPLEMENTATION ステップ逸脱時の対応

### 逸脱 1: Step 1 (品質ゲートコマンド取得) のスキップ

#### 症状

- 品質ゲートコマンドが不明確のままコーディング開始
- Step 5 で実行するコマンドが見当たらない
- 環境固有のコマンド引数を見落とし

#### 原因

- `package.json`、設定ファイルの確認が不十分
- プロジェクト固有の build スクリプトの認識漏れ
- 開発ツールのバージョン確認不足

#### 対応

1. **プロジェクト設定を確認**

   ```bash
   # Node.js の場合
   cat package.json | jq '.scripts'

   # Python の場合
   cat setup.py | grep -A5 "test_suite"

   # Rust の場合
   cat Cargo.toml | grep -A5 "\[package\]"
   ```

2. **各ツールのコマンド確認**

   ```bash
   # Lint コマンド
   npm run lint --help

   # 型チェックコマンド
   npm run check:types --help

   # テストコマンド
   npm run test --help
   ```

3. **コマンド実行可能性テスト**

   ```bash
   # 各コマンドを実際に実行
   npm run lint
   npm run check:types
   npm run test

   # 出力形式・成否フラグを記録
   ```

4. **Step 2 に進む**

---

### 逸脱 2: Step 2 (実装タスクリスト作成) の不完全実行

#### 症状

- タスク粒度が大きすぎる
- 複数テストが 1 タスクに混在
- タスク間の依存関係が明確でない

#### 原因

- 要件分析が浅い
- テストケースの列挙が不十分
- Given-When-Then の詳細化がない

#### 対応

1. **要件を詳細に分析**
   - 正常系、異常系、エッジケースを列挙
   - 各ケースに対応するテストケースを定義

   ```markdown
   # 例: 電子メールバリデーション機能

   ## 正常系

   - Task 1: 有効なメールアドレスでテスト成功

   ## 異常系

   - Task 2: @記号がない場合、エラー返却
   - Task 3: ドメイン部分がない場合、エラー返却

   ## エッジケース

   - Task 4: 空文字列でテスト失敗
   - Task 5: スペース含む場合、エラー返却
   ```

2. **各タスク内で Given-When-Then を詳細化**

   ```markdown
   - Task 1:
     - Given: ユーザーが "user@example.com" を入力
     - When: バリデーション実行
     - Then: 結果が true
   ```

3. **タスク間の依存関係を明確化**

   ```markdown
   Task 1 (正常系) ← 最初に実装
   ↓
   Task 2, 3, 4 (異常系・エッジケース) ← 次に実装
   ```

4. **Step 3 に進む**

---

### 逸脱 3: Step 3 (BDD 実装) での複数タスク並行実装

#### 症状

- deckrd-bdd-coder に複数タスクを同時指示
- 処理が混乱し、実装品質が低下
- テストケース間の影響関係が発生

#### 原因

- **1 message = 1 task** 原則の理解不足
- メモリ制約を過小評価
- 処理効率を優先して規則を破る

#### 対応

1. **厳格に 1 タスク = 1 メッセージとする**

   ```bash
   # 悪い例
   /coding T01-02 T01-03 T01-04

   # 良い例
   /coding T01-02          # 1 メッセージ
   # 完了待ち
   /coding T01-03          # 次のメッセージ
   # 完了待ち
   /coding T01-04          # 次のメッセージ
   ```

2. **deckrd-bdd-coder のエラー対応**
   - 実装中にエラーが発生した場合、即座にロールバック
   - エラー内容をユーザーに報告
   - **エラー 3 回以上時: ユーザー相談 (巻き戻し判定)**

3. **Step 4 (繰り返し判定) に進む**

---

### 逸脱 4: Step 3 (BDD 実装) での Green フェーズ過剰実装

#### 症状

- テスト合格に不要な実装が追加される
- Refactor フェーズの負担が増加
- コード品質が低下

#### 原因

- Green フェーズの目的 (最小実装) の理解不足
- 将来性を考慮した実装をしてしまう
- テストコード曖昧性による過実装

#### 対応

1. **Green フェーズの制約を厳格化**

   ```typescript
   // 悪い例: 複数の結果値を実装
   function validate(email: string): boolean {
     if (!email.includes('@')) { return false; }
     if (!email.includes('.')) { return false; // 次のテストで必要
      }
     if (email.length < 5) { return false; // さらに次のテストで必要
      }
     return true;
   }

   // 良い例: 現在のテストのみ実装
   // Task 1: 有効なメールアドレスでテスト成功
   function validate(email: string): boolean {
     return true; // テストが要求する最小限
   }

   // Task 2: @記号がない場合、エラー返却
   function validate(email: string): boolean {
     return email.includes('@'); // このテストのみ対応
   }
   ```

2. **テストケースを明確に定義**
   - 各タスクのテストケースが 1 つであることを確認
   - テスト内容が曖昧でないことを確認

3. **Refactor フェーズで統合的に改善**
   - Green で実装した複数ステップを統合
   - 重複ロジックを関数抽出

4. **Step 4 に進む**

---

### 逸脱 5: Step 4 (繰り返し判定) の判断ミス

#### 症状

- 未実装タスクが残ったまま Step 5 へ進む
- 逆に、完了済みタスクが残っていると誤認して Step 3 へ戻る
- ループから抜け出せない

#### 原因

- 実装タスクリストのチェック状況確認が不十分
- タスク完了条件が曖昧

#### 対応

1. **実装タスクリストを明確に確認**

   ```markdown
   # チェック状況を一覧表示

   - [x] Task 1: ... (テスト合格、品質ゲート合格)
   - [x] Task 2: ... (テスト合格、品質ゲート合格)
   - [ ] Task 3: ... (未実装) ← まだある！
   ```

2. **タスク完了の判定基準**
   - [ ] テスト実装済み
   - [ ] テスト PASS
   - [ ] 実装コード完成
   - [ ] Lint チェック合格
   - [ ] 型チェック合格

3. **判定結果に基づき分岐**

   ```bash
   未実装タスク あり
     → Step 3 へ戻る (次のタスク実装)

   未実装タスク なし
     → Step 5 へ進む (全体品質ゲート)
   ```

---

### 逸脱 6: Step 5 (品質ゲート実行) での失敗対応の混乱

#### 症状

- 品質ゲート失敗時の対応が体系的でない
- Step 7 (Refactor) へ戻るべきか Step 3 へ戻るべきか判断がつかない
- エラーが繰り返し発生する

#### 原因

- Step 5 での失敗とタスク内の失敗の区別がない
- 対応の流れが設計されていない
- エラーカウントの管理がない

#### 対応

1. **品質ゲート失敗時のフロー**

   ```bash
   Step 5: 品質ゲート実行
     ↓
   失敗？
     ├─ NO → Step 6 へ進む
     └─ YES → 失敗カウント +1
         ↓
       失敗カウント ≤ 2
         → エラー分析・修正
         → Step 5 再実行

       失敗カウント = 3
         → ユーザーに相談
         → Step 3 へ戻るか Step 7 へ戻るか判定
   ```

2. **エラー別の対応マトリックス**

   | エラー種別                    | 対応                            | 戻り先              |
   | ----------------------------- | ------------------------------- | ------------------- |
   | Lint 失敗 (単純な様式違反)    | コード様式修正                  | Step 5 再実行       |
   | 型チェック失敗 (型定義エラー) | インポート・型注釈修正          | Step 5 再実行       |
   | テスト失敗 (実装バグ)         | 実装ロジック修正 → テスト再実行 | Step 3 (該当タスク) |
   | 複合エラー (3 個以上)         | 全体構造の見直し                | Step 7 (Refactor)   |

3. **エラー情報の記録**
   - エラーメッセージ全文を記録
   - ファイル・行番号を特定
   - エラーの根本原因を分析

4. **Step 6 へ進む**

---

### 逸脱 7: Step 6 (進捗記録) の忘却

#### 症状

- 完了したタスクが実装タスクリストに反映されない
- あとで何が完了したか追跡できない
- Step 8 の完了判定が曖昧になる

#### 原因

- Step 6 の重要性の認識不足
- Todo リストと実装タスクリストの同期忘れ
- 手動更新の面倒さ

#### 対応

1. **実装タスクリストを即座に更新**

   ```markdown
   # Step 6 実行直後

   - [x] Task 1: 入力値が有効な場合、結果 A を返す (正常系)
   - [x] Task 2: 入力値が null の場合、エラーを返す (異常系)
   - [ ] Task 3: 入力値が空文字列の場合、デフォルト値を返す (エッジケース)
   ```

2. **TodoWrite で進捗を同期**

   ```bash
   # メモリや TodoWrite に完了を記録
   ```

3. **進捗状況の可視化**
   - 完了済みタスク数 / 総タスク数を計算
   - 進捗率を記録
   - ユーザーに報告

4. **Step 7 へ進む**

---

### 逸脱 8: Step 7 (Refactor フェーズ) のスキップ

#### 症状

- テストが通った時点で完了判定してしまう
- コード品質が低い (重複、複雑性が高い)
- 保守性が低下

#### 原因

- Refactor フェーズの重要性の理解不足
- テスト通過 = 完了という誤解
- 時間圧縮のため Phase をスキップ

#### 対応

1. **Refactor フェーズは必須**
   - テストが通った ≠ 実装完了
   - テストが通った後に、コード品質改善が必須

2. **Refactor の具体的タスク**

   **テストコードの整理**:

   ```typescript
   // 悪い例: 重複テスト
   it('should return A when input is "abc"', () => {
     expect(validate('abc')).toBe(true);
   });
   it('should return A when input is "def"', () => {
     expect(validate('def')).toBe(true);
   });
   it('should return A when input is "ghi"', () => {
     expect(validate('ghi')).toBe(true);
   });

   // 良い例: パラメータ化テスト
   it.each(['abc', 'def', 'ghi'])('should return A when input is "%s"', (input) => {
     expect(validate(input)).toBe(true);
   });
   ```

   **実装コードの整理**:

   ```typescript
   // 悪い例: 重複ロジック
   function processOrder(type: 'A' | 'B') {
     if (type === 'A') {
       validate();
       calculate();
       save();
     } else {
       validate();
       calculate();
       save();
     }
   }

   // 良い例: 重複排除
   function processOrder(type: 'A' | 'B') {
     validate();
     calculate();
     save();
   }
   ```

3. **ユーザーと Refactor 案を協議**
   - 提案内容をユーザーに説明
   - ユーザーの意見を反映
   - Refactor の実行・検証

4. **Refactor 後の検証**

   ```bash
   npm run test          # すべてのテストが PASS
   npm run lint          # Lint チェック合格
   npm run check:types   # 型チェック合格
   ```

5. **Step 8 へ進む**

---

### 逸脱 9: Step 8 (完了判定) での検証不足

#### 症状

- 実装が完全でないまま完了と判定される
- ユーザーが追加修正依頼を出す
- ワークフローが巻き戻される

#### 原因

- 完了チェックリストの項目が曖昧
- チェック漏れ (見落とし)
- チェック結果の記録がない

#### 対応

1. **完了チェックリスト (100% 達成必須)**

   ```markdown
   ## テスト完了の確認

   - [x] すべてのテストケースが実装済み
   - [x] すべてのテストが PASS
   - [ ] (テストカバレッジ = 100%) # 必要に応じて

   ## 品質ゲート合格の確認

   - [x] Lint チェック: 合格
   - [x] 型チェック: 合格
   - [x] その他プロジェクト固有チェック: 合格

   ## Refactor 完了の確認

   - [x] テストコード整理完了
   - [x] 実装コード整理完了
   - [x] ユーザーが内容に承認

   ## 最終確認

   - [x] ドキュメント更新 (必要な場合)
   - [x] コミット準備完了 (ユーザーが手動実施)
   ```

2. **チェック項目に偽りがないか確認**

   ```bash
   # テスト実行結果を確認
   npm run test

   # Lint 結果を確認
   npm run lint

   # 型チェック結果を確認
   npm run check:types
   ```

3. **チェック結果の記録**
   - 完了日時を記録
   - チェック項目の実行コマンド・出力を記録
   - ユーザーの承認を記録

4. **判定**

   ```bash
   すべてのチェック項目 = [x]
     → 実装完了！ワークフロー終了

   チェック項目に [  ] がある
     → Step 7 へ戻って不足部分を対応
   ```

---

## よくある質問と回答

### Q: Step 3 で 3 回エラーが出た。どうすればいい？

**A**: 以下の対応を実施してください。

1. **ロールバック**: 実装を前のコミット時点まで戻す
2. **原因分析**: エラーが何度も出る根本原因を分析
   - テストケースが曖昧？
   - 実装環境に問題？
   - deckrd-bdd-coder の動作異常？
3. **ユーザーに相談**
   - 問題状況を報告
   - 対応案を提示
   - ユーザーの指示を仰ぐ

---

### Q: 品質ゲートで Lint エラーが出た。Step 3 と Step 5 どちらで対応？

**A:** エラーの種類で判定:

| エラー内容                  | 対応フェーズ              | 理由                           |
| --------------------------- | ------------------------- | ------------------------------ |
| 個別タスク内の Lint エラー  | Step 3 内の品質ゲート確認 | タスク完了時点で検出すべき     |
| Step 5 全体実行で初めて出現 | Step 5 で修正             | 複数タスク統合時の問題の可能性 |

---

### Q: Phase 5 では何をするんですか？

**A:** Phase 5 (完了確認) は以下を実施します。

1. **実装タスクリストの確認**
   - すべてのタスクが `[x]` (完了) であることを確認
   - 未実装タスク (`[ ]`) が残っていないことを確認

2. **全体テスト実行**
   - すべてのテストが PASS していることを確認

3. **Refactor 完了確認**
   - Step 7 で全体コード整理が実施されたことを確認
   - ユーザーが内容に承認していることを確認

4. **進捗記録確認**
   - Step 6 で実装タスクリスト・Todo が更新されたことを確認

この 4 つがすべて確認できたら Phase 6 へ進みます。

---

### Q: Refactor が必要ないケースもあるのでは？

**A:** **いいえ。Refactor は常に必須です。**

理由:

- Red-Green サイクルで実装したコードは、最小限で重複や複雑さが残る
- テストが通っているだけでは品質の高さを保証しない
- 保守性・読みやすさは Refactor フェーズで初めて確保される

ただし、Refactor の規模が小さい場合:

- 小規模タスク：軽微な変数名改善のみ
- 大規模タスク：関数抽出、ロジック統合など

---

## トラブルシューティング判定ツリー

```bash
問題発生
  ↓
Phase / Step のどの段階で発生？
  ├─ Phase 0 → 開発環境把握に戻る
  ├─ Phase 1 → Session JSON 確認
  ├─ Phase 2 → タスク細分化を再実施
  ├─ Phase 3 → Step 3-4 詳細フロー参照
  ├─ Phase 4 → 品質ゲート失敗対応フロー参照
  ├─ Phase 5 → 完了確認チェックリスト参照
  └─ その他 → ユーザーに相談

エラーが 3 回以上発生
  → ロールバック・ユーザーに相談
```

---

## 参考資料

- [WORKFLOW.md](./workflow.md) - Phase 0-6 詳細フロー
- [IMPLEMENTATION.md](./implementation.md) - Step 1-8 詳細手順
- `.claude/agents/bdd-coder.md` - BDD エージェント仕様
- `CLAUDE.md` - プロジェクトルール全般
